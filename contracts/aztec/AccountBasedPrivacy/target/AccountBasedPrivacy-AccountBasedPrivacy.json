{
  "transpiled": true,
  "noir_version": "1.0.0-beta.5+0000000000000000000000000000000000000000",
  "name": "AccountBasedPrivacy",
  "functions": [
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vb3RruzIcXb5Ln2ti4qMjMhMvcoPw5Bl2RAgSIYsDzAw9O5TDDJi1d79V57atU/PjXqp+5xvsViMYDGZTP7vL//+p3/7n//81z//9T/+9t+//P7//O8v//b3P//lL3/+z3/9y9/++Id//Plvf73/2//95Xb8j9zmL7/X393/uX75vd3/Kfd/PY5/yi+/X8c/2y+/FzlAE3qCJXjCSJgJ64J2S5CETG6Z3DK5ZXLL5JbJLZNbJmsmayZrJmsmayZrJmsmayZrJmsm90zumdwzuWdyz+SeyT2Teyb3TO6ZbJlsmWyZbJlsmWyZbJlsmWyZbJnsmeyZ7JnsmeyZ7JnsmeyZ7JnsmTwyeWTyyOSRyeNIbgdYgieMhJmwLphH8nHwzSP5OPpmS9CEnmAJnjASZsK6YN0SMnndk9shXZrQEyzBE0bCTFgntNstQRJagib0BEvwhJEwEzJZMlkyWTJZMlkyWTJZMlkyWTJZMvmowWYHSEJL0ISeYAmeMBJmwrpAM1kzWTNZM1kzWTNZM1kzWTNZM7lncs/knsk9k3sm90zumdwzuWdyz2TLZMtky2TLZMtky2TLZMtky2TLZM9kz2TPZM9kz2TPZM9kz2TPZM/kkckjk0cmj0wemTwyeWTyyOSRySOTjxps8wBJaAma0BMswRNGwkxYF6xMXpm8Mnll8lGDehyiRw2e4AkjYSasE/SowRMkoSVoQk+wBE8YCUeyHbAuOGrwBEloCZrQEyzBE0ZCJksmt0xumXzUoK4DNKEnWIInjISZsC44avAESchkzWTNZM1kzWTNZM1kzeSeyT2Teyb3TO6Z3DO5Z3LP5J7JPZMtky2TLZMtky2TLZMtky2TLZMtkz2TPZM9kz2TPZM9kz2TPZM9kz2TRyaPTB6ZPDJ5ZPLI5JHJI5NHJo9Mnpk8M3lm8szkmckzk2cmz0yemTwzeWXyyuSVySuTVyavTF6ZvDJ5ZfK6kvvtliAJLUETeoIleMJImAmZLJksmSyZLJksmSyZLJksmSyZLJncMrllctZgzxrsWYP9qMEuB3jCSJgJ64KjBk+QhJagCT0hkzWTNZM1kzWTeyb3TO6Z3DO5Z3LP5J7JPZN7JvdMtky2TLZMtky2TLZMtky2TLZMtkz2TPZM9kz2TPZM9kz2TPZM9kz2TB6ZPDJ5ZPLI5JHJI5NHJo9MHpk8Mnlm8szkmckzk2cmz0yemTwzeWbyzOSVySuTVyavTF6ZvDJ5ZfLK5JXJ60q22y1BElqCJvQES/CEkTATMlkyWTJZMlkyWTJZMlkyWTJZMlkyuWVyy+SWyS2TWyZnDVrWoGUNWtagZQ1a1qBlDVrWoGUNWtagZQ1a1qBlDVrWoGUNWtagZQ1a1qBlDVrWoGUNWtagZQ1a1qBlDVrWoGUNWtSgHaAJPcESPGEkzIR1QdRggCRksmeyZ7Jn8lGD1g4YCTNhXXDU4AmS0BI0oSdYQiaPTB6ZPDJ5ZvLM5JnJM5NnJs9Mnpk8M/moQesHrAuOGjxBElqCJvQES/CEkZDJ60r22y1BEo5kO0ATeoIleMJImAnrgqMGT5CETJZMlkyWTD5q0OYBI2Em3JP9doejBk+QhJagCT3BEjxhJMyETNZM1kzWTD5q0PWAnmAJnjASZsK64KjBEyShJWRyz+SeyT2Tjxr049s5avCEdcFRgydIQkvQhJ5gCZ6QyZbJlsmeyZ7JnsmeyZ7JnsmeyZ7JnsmeySOTRyaPTB6ZPDJ5ZPLI5JHJI5NHJs9Mnpk8M3lm8szkmckzk2cmz0yembwyeWXyyuSVySuTVyavTF6ZvDJ5XcnjdkuQhJagCT3BEjxhJMyETJZMlkyWTJZMlkyWTJZMlkyWTJZMbpncMrllcsvklsktk1smt0xumdwyWTNZM1kzWTNZM1kzWTNZM1kzWTO5Z3LUoB/QEjShJ1iCJ4yEmbAuiBoMyGTLZMtky2TLZMtky2TLZMtkz2TPZM9kz2TPZM9kz2TPZM9kz+SRySOTRyaPTB6ZPDJ5ZPLI5JHJI5NnJs9Mnpk8M3lm8szkmckzk2cmz0xembwyeWXyyuSVySuTVyavTF6ZvK7kebslSEJL0ISeYAmeMBJmQiZLJksmSyZLJksmSyZLJksmSyZLJrdMbpncMrllcsvklsktk1smt0xumayZrJmsmayZrJmsmayZrJmsmayZ3DM5a3BmDc6swZk1OLMGZ9bgzBqcWYMza3BmDc6swZk1OLMGZ9bgzBqcWYMza3BmDc6swZk1OLMGZ9bgzBqcWYMza3BmDc6swZk1OLMGZ9bgzBqcWYMza3BmDc6swZk1OLMGZ9bgzBqcWYMza3BmDc6swZk1OLMGZ9bgzBqcWYMza3BmDc6swZk1OLMGZ9bgzBqcWYMza3BmDc6swZU1uLIGV9bgyhpcWYMra3BFDa4DRsJMWBdEDQZIQkvQhJ5gCZksmSyZLJl81OC4HSAJLUETeoIleMJImAnrAs1kzWTNZM1kzWTNZM1kzWTNZM3knsk9k3sm90zumdwzuWdyz+SeyT2TLZMtky2TLZMtky2TLZMtky2TLZM9kz2TPZM9kz2TPZM9kz2TPZM9k0cmj0wemTwyeWTyyOSRySOTRyYfNTjuPzPWUYMnSEJL0ISeYAmeMBJmQiavTD5qcIwDWoIm9ARL8ISRMBPWCXI7ivAiKWpFWtSLrMiLRtEsKoeUQ8oh5ZBySDmkHFIOKYeUQ8rRytHK0crRytHK0crRytHK0crRyqHl0HJoObQcWg4th5ZDy6Hl0HL0cvRy9HL0cvRy9HL0cvRy9HL0clg5rBxWDiuHlcPKYeWwclg5rBxeDi+Hl8PL4eXwcng5vBxeDi/HKMcoxyjHKMcoxyjHKMcoxyjHKMcsxyzHLMcsxyzHLMcsxyzHLMcsxyrHKscqxyrHKscqxyrHKscqR9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVuVSdS9W5VJ1L1blUnUvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzmOe0LwFedEomkUr6ajzi6SoFWlRLyqHl8PL4eU46nwek9Zi2tBFUtSKtKgXWZEXjaJZVI5ZjlmOWY5ZjlmOWY5ZjlmOWY5ZjlWOVY5VjlWOVY5VjlWOVY5VjpWOmFR0kRS1Ii3qRVbkRaNoFpVDyiHlkHJIOaQcUg4ph5RDyiHlaOVo5WjlaOVo5WjlaOVo5WjlaOXQcmg5tBxaDi2HlkPLoeXQcmg5ejl6OXo5ejl6OXo5ejl6OXo5ejmsHFYOK4eVw8ph5bByWDmsHFaOqHMNkqJWpEW9yIq8aBTNopU0yjHKMcoxyjHKMcoxyjHKMcoxyjHLMcsxyzHLMcsxyzHLMcsxyzHLscqxyrHKscqxyrHKscqxyrHKsdIRE5cukqJWpEW9yIq8aBTNonJIOaQcUg4ph5RDyiHlkHJIOaQcrRytHK0crRytHK0crRytHK0crRxaDi2HlkPLoeWIOh9BXjSK7o51C1pJR51fJEWtSIt6kRV50SgqRy+HlcPKYeWwclg5rBxWDiuHlcPK4eXwcng5vBxeDi+Hl8PL4eXwcoxyjHKMcoxyjHKMcoxyjHKMcoxyzHLMcsxyzHLMcsxyzHLMcsxyzHKscqxyrHKscqxyrHKscqxyrHKsdMTkqIukqBVpUS+yIi8aRbOoHFIOKYeUQ8oh5ZBySDmkHFIOKUcrRytHK0crRytHK0crRytHK0crh5ZDy6Hl0HJoObQcWg4tR9W5VZ1b1blVnVvVuVWdW9W5VZ1b1blVnVvVuVWdW9W5VZ1b1blVnVvVuVWdW9W5VZ1b1blVnVvVuVWdW9W5VZ1b1blVnVvVuVWdW9W5VZ1b1blVnVvVuVWdW9W5VZ1b1blVnVvVuVWdW9W5VZ1b1blVnVvVuVWdW9W5VZ1b1blVnVvVuVWdW9W5VZ1b1blVnVvVuVWdW9W5VZ171blXnXvVuVede9W5V5171blXnXvVuVede9W5V5171blXnXvVuVede9W5V5171blXnXvVuVede9W5V5171blXnXvVuVede9W5V5171blXnXvVuVede9W5V5171blXnXvVuVede9W5V5171blXnXvVuVede9W5V5171blXnXvVuVede9W5V5171blXnXvVuVede9W5V5171blXnXvVuVede9W5V5171blXnXvVuVede9W5V5171blXnXvVuVede9W5V5171blXnXvVuVede9W5V5171blXnXvVuVede9W5V5171blXnXvVuVede9W5V5171blXnXvVuVedj6rzUXU+qs5H1fmoOh9V56PqfFSdj6rzUXU+qs5H1fmoOh9V56PqfFSdj6rzUXU+qs5H1fmo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",
      "brillig_names": [
        "sync_private_state"
      ]
    },
    {
      "name": "transfer",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkAAAAA//////////8AAq8EVzp/9IdSs65R\njeUIm/Qga+u7HvC0QZ1WnnAbipAbiTiJ/LKfxo+Q0auJbzGEExjfVONxVkYcrejYiDeY5w/3hRI3\n1738AUGr6q5R1b/T6vdwcX81mUtXBhK4w5vEBTW8kLhlC40i09CbOqquUI0Mcb1ihW7S4GVr2cUG\nvvsBkQhLSdwkMxfeM4eKLhEmhbESm0j2hzMk51M0IcoS7wAKI00ledfJPIkfvLLeSw5a8O2PRnDy\nGYKLzTECNRekGRofB2RgXgkIdSidYVCbSvRTYmYBSBDgP9hyTF23YdwLs9gDwwtNCDAO7yErwKoP\nfTj85UlrRVntUFvm4A+5bAu6SB4j7QUDgWJHCOZoHmvewax3g6gwUjwZDaSsyIMGJ4g3lj63a/ci\n1FWl7OcVnnJ7/DN8+twldmD51S6U5wIX4LkFSdhSVFt2C7SJ55Oc6az4sRuTPldNzD5ecfoDHgSt\nsHdvk+v+z3EfCXqr+9q4b23FaMQV/oLSZ4G6buefJ34e3MIBh/bZnQqcjCd6Eo8n4+S1X0QwM2Q7\nBxTO32ERhG3XjR3FaaW5IHNUc4FjfZjumN7m5SaIFHQ/qD0KTCmMMxH8kXD5LelAsEKquZDVPGo7\nJjOc2mtz35IIMUFZB7BfQIphKEclkBa5IErkvzdTfrGWsFwdmPpRAWqbrLsB4uQjmXFnYxUAJlUD\nWHTJeC7GBtShiEF9afnwXzp/+y2umi7Mb43cmVeDJ4H/mXfjOGyq3fyCEKUOZqiRy3C9D9GMXD74\nfaRGCEyO2nn+a5EEC6ZCkZzAeOTBjEyKKPcDyrpDy8DlpDrEfksFnY59Ezv93Lszz+V0VIET1BLp\nIiHrSJuRmKhkLL92LlSOA5ve52T8+85x9jwkt2+sZv9oEf1BtfmTbZMquuTG6TPg05wk6o4uDu5w\nKlMm81nJR8AUoX18ClXS1F7o7fbsFlwRPSgrmEfVYv1BQCIOR+GCrxpw0tC/U/KBmNxua015bsn0\nE4YWuRKVxKct3D6sKlhhFl8WW5L5kEuf4sqGtQxoX5owM7vHLtg4a9PjeHBWVR8s68Kk9S3IiO/I\nw/k6CtwnQs+xOKkb5L2Hc+vA78ElXgZ9eSFtjwYW55qHbNgYAOOQrTZTwVIqOlncJI3Ub9lPGJEu\ntqVLfYW4b/Q4513J6dtojtQb4OTb3osDp6Kr7FoaSBUzzPPyMIi1faswKm4zqTxO9j1UqikYAAtb\ntdH+PAjtK0N3eVX9VEyY8YbR+4eS7WO4HebF3Ka4gDwY9CPMC94fmZwLvMHTPitux5IY6bJutez3\nrfV3yiRgSrebvd8QnLE30C7GroTrJ+Zi2JNbg0hs9EOAMgERv9vSm8I8NB0ir5AB4oIVDgTFxcSE\nJBwIw0esjIRGFkhgNqsTC2GuKUn90veqM9Ub9R5PARqlIgcoiM47b5ctkqq2oElcYu8bLcYZCSbm\nHBp2GXOn6NWeH6qCuk2a0Jku5yEvA1CYJibDMVqWB9PV4Ni8PX1WJmnv86UvOzul5msPzI2Z95GX\nJhIv58I6r5Q8pMnkonfpB9uEi2oF1Q0yHNGRpv+tcBcWvzRMuvV5BgV3ynx171wzp7qKbmIjLAXH\nGEc3Ao69/RZzpUEO6xdBR5UTLnne9llBlit+enCRbUXUU3Ev9aWdIpJd7zHmfPHszfoy6YoFSoaQ\nEh9zR6qbw5mWmuuH7u0ExvB8GgLF+11V2mOXUQPiRGR0QqwpAfcyHdUpsMBtMQyel1bqXvHW6mRL\nIk3efEnvLz+drnaeIRsNHONa03bHIlep//BVK8o/TlPVdT9ys9KW9A9SEp40ejqSSbJckHgf6ciG\nuNueapy37MEfcILaR8RB7+3l3ByAqD08ZBP1ZQrcicSNdbVxY29bvrSoBvb0WWICMBtq5OsOu+rd\nIDNABm8oE1dI8RljHD/gf6nXAANOPidFTvmStL+EuXuqdHEuJXg1Ud9QwATsfNH03Ys7ZKZvKsSX\nm2XlZWjFoxsU7Rj3bPDO7MtHmN50GuibZOglj4RHfBtiVlpVm6e7OIMuLSmftoZ40BULzFsW3IJS\nNT1D+nDpkjnBwcZ+JxoO6sUV06xaGZq7dJM6TvyYxZsoFO3nzSfa7QDDPBKGC8SwRi041tS6Hkdj\np07NsRyh80aWgMJw5VFRU0RZL1kYj6dlEts56JKCazJhDuCCUeAF/OkXwNXcoBlHfFL2B1MythIA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAACIQV7rPyQpKCnIkzsjr93BWmWJV+CHgYEJxC4S1SIeZANddfD+bWXf0iSG6kMaDbVWrrJ\nKFLdgULUvyK0TO97OwDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMk\ngqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJiS18GKk8\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "1752556835457866331": {
            "error_kind": "string",
            "string": "No public functions"
          }
        }
      },
      "bytecode": "JwAABAEqAAABBRhSVSgKJhpbPAAAAQ==",
      "debug_symbols": "XY1bCoAgEEX3Mt+toK1EiI9RBkRl0iDEvWeRIH3ee+6jgkFVnKBg4wHrVkExeU9O+Khlphi6W9sCQ4rMiN2CiW97D0hN/C+dkkkqj5+0JeiJ5isNMk4TR42mMD5LL2t7uwE=",
      "brillig_names": [
        "public_dispatch"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "OneWayNote"
            },
            {
              "fields": [
                {
                  "name": "secret",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "account_nonce",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "amount_spent",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "AccountBasedPrivacy"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "received_amounts",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "spent_amounts",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "sender",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "recipient",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            },
            {
              "name": "embedded_amount_nonce",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AccountBasedPrivacy::Transfer"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AccountBasedPrivacy::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AccountBasedPrivacy::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "AccountBasedPrivacy::transfer_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "note",
                    "type": {
                      "fields": [
                        {
                          "name": "secret",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "account_nonce",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "amount_spent",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "OneWayNote::OneWayNote"
                    }
                  },
                  {
                    "name": "contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "metadata",
                    "type": {
                      "fields": [
                        {
                          "name": "stage",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 8
                          }
                        },
                        {
                          "name": "maybe_nonce",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::note::note_metadata::NoteMetadata"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::note::retrieved_note::RetrievedNote"
              }
            }
          ],
          "kind": "struct",
          "path": "AccountBasedPrivacy::transfer_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "102": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "103": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "105": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::fetch_tagged_logs},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "106": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "107": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "108": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "126": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "129": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "131": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",
      "source": "use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = packed_retrieved_note[2] as bool;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, nonce),\n    }\n}\n"
    },
    "132": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "136": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "138": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "139": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "147": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "148": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    // The log fields length is PUBLIC_LOG_SIZE_IN_FIELDS. + 1 because the contract address is prepended to the content.\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_SIZE_IN_FIELDS + 1>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "150": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "152": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "179": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "182": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "183": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "185": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "186": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "188": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "190": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "201": {
      "path": "/home/jimjim/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "218": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "280": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "281": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "295": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "298": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "337": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "338": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "367": {
      "path": "/home/jimjim/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "50": {
      "path": "/home/jimjim/Desktop/AccountBasedPrivacy/contracts/aztec/AccountBasedPrivacy/src/OneWayNote.nr",
      "source": "use dep::aztec::{macros::notes::note, protocol_types::{hash::poseidon2_hash, poseidon2, address::AztecAddress, traits::Serialize}};\nuse dep::aztec::macros::notes::{custom_note};\nuse dep::aztec::note::note_interface::{NoteHash};\nuse dep::aztec::context::{PrivateContext};\nuse aztec::note::note_interface::NoteHash::{compute_nullifier, compute_note_hash};\n\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct OneWayNote {\n    secret: Field,\n    account_nonce: Field,\n    amount_spent: u128,\n}\n\nimpl OneWayNote {\n    pub fn new(secret: Field, account_nonce: Field, amount_spent: u128) -> Self {\n        OneWayNote { secret, account_nonce, amount_spent }\n    }\n}\n\nimpl NoteHash for OneWayNote {\n    // just ignoring storage_slot for now\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        poseidon2_hash([self.secret, self.account_nonce, self.amount_spent as Field])\n    }\n\n    fn compute_nullifier(self,context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        poseidon2_hash([self.secret, self.account_nonce])\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        poseidon2_hash([self.secret, self.account_nonce])\n    }\n}"
    },
    "51": {
      "path": "/home/jimjim/Desktop/AccountBasedPrivacy/contracts/aztec/AccountBasedPrivacy/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\nmod OneWayNote;\n\n#[aztec]\npub contract AccountBasedPrivacy {\n    use crate::OneWayNote::OneWayNote;\n    use aztec::macros::{functions::{initializer, private, public, utility}, storage::storage};\n    use aztec::prelude::{AztecAddress, Map, PrivateSet, PrivateMutable, PublicMutable};\n    use aztec::protocol_types::{\n        abis::function_selector::FunctionSelector,\n        traits::{FromField, ToField},\n    };\n    use aztec::messages::logs::{\n            //event::encode_and_encrypt_event,\n            note::{encode_and_encrypt_note, encode_and_encrypt_note_unconstrained},\n        };\n    use aztec::note::{\n            note_getter::{get_note_internal, get_notes},\n            note_interface::NoteHash::{self, compute_note_hash, compute_nullifier},\n            retrieved_note::RetrievedNote,};\n    use std::embedded_curve_ops::{\n        embedded_curve_add, EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,fixed_base_scalar_mul\n    };\n\n    use std::hash::pedersen_commitment;\n\n    use aztec::{\n        context::{PrivateCallInterface, PrivateContext},\n        event::event_interface::EventInterface,\n        history::public_storage::{PublicStorageHistoricalRead},};\n\n    use aztec::keys::{ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address, ephemeral::{generate_ephemeral_key_pair}};\n    use aztec::utils::{point::get_sign_of_point,with_hash::WithHash::historical_public_storage_read};\n    use aztec::oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret};\n    use dep::aztec::{\n    macros::{\n        events::event,\n    },};\n\n    use std::{meta::derive, ops::{Add, Sub}};\n    use dep::aztec::protocol_types::traits::Serialize;\n    use dep::aztec::oracle::random::random;\n\n    #[storage]\n    struct Storage<Context> {\n        received_amounts: Map<AztecAddress, PublicMutable<EmbeddedCurvePoint, Context>, Context>,\n        spent_amounts: PrivateSet<OneWayNote, Context>,\n    }\n\n    #[derive(Serialize)]\n    #[event]\n    struct Transfer {\n        sender: AztecAddress,\n        recipient: AztecAddress,\n        amount: u128,\n        embedded_amount_nonce: Field\n    }\n\n    #[private]\n    fn transfer(\n        recipient: AztecAddress, \n        amount: u128\n        ) ->  RetrievedNote<OneWayNote> {\n        let sender = context.msg_sender();\n\n        let spent_amounts_storage_slot = storage.spent_amounts.storage_slot;\n        // Safety: its fine\n        let retrieved_prev_OneWayNote: RetrievedNote<OneWayNote> = unsafe { get_note_internal::<OneWayNote, 3>(spent_amounts_storage_slot) }; \n        retrieved_prev_OneWayNote\n    }\n\n    // #[private]\n    // fn transfer(\n    //     recipient: AztecAddress, \n    //     amount: u128\n    //     ) {\n    //     // //TODO handle account nonce 0 case. if at zero we don't need prev_OneWayNote, if we can create OneWayNote(nonce=0) and we can push it's nullifier, everything is fine\n    //     let sender = context.msg_sender();\n        \n    //     // get prev amount spent and note\n    //     let spent_amounts_storage_slot = storage.spent_amounts.storage_slot;\n    //     // // Safety: its fine\n    //     let retrieved_prev_OneWayNote: RetrievedNote<OneWayNote> = unsafe { get_note_internal::<OneWayNote, 3>(spent_amounts_storage_slot) }; \n    //     let prev_amount_spent = retrieved_prev_OneWayNote.note.amount_spent;\n    //     // you can probably use something like destroy note unsafe or what ever.\n    //     let prev_note_hash =  retrieved_prev_OneWayNote.note.compute_note_hash(spent_amounts_storage_slot);\n    //     let nullifier = retrieved_prev_OneWayNote.note.compute_nullifier(&mut context, prev_note_hash);\n    //     context.push_nullifier(nullifier);\n        \n    //     // // can we spent this now?\n    //     let amount_received = 0x123; //get_amount_received(); // reads logs from PXE and asserts that received_amounts.at(sender) == pederson(totalAmountFromEncryptedLog)\n    //     let new_amount_spent = amount + prev_amount_spent;\n    //     assert(amount_received >= new_amount_spent);\n\n\n    //     // // track what we spent\n    //     let new_OneWayNote: OneWayNote = OneWayNote {\n    //         secret: retrieved_prev_OneWayNote.note.secret,\n    //         account_nonce: retrieved_prev_OneWayNote.note.account_nonce + 1,\n    //         amount_spent: new_amount_spent,\n    //     };\n\n    //     storage.spent_amounts.insert(new_OneWayNote).emit(encode_and_encrypt_note(\n    //         &mut context,\n    //         sender,\n    //         sender,\n    //     ));\n\n\n    //     // we could have used the shared secret of encode_and_encrypt_event but idk how, so lets just add an extra field with some randomness from the oracle (aka PXE)\n        \n    //     // Safety: it's in the senders best interest to indeed use real randomness, if not this tx amount is doxxed for the sender and recipient. But total balances aren't\n    //     let embedded_amount_nonce = unsafe{ random() };\n    //     // \n    //     let embedded_amount = pedersen_commitment([amount as Field, embedded_amount_nonce]);\n    //     // needs to be constrained, since if its not. recipient will wont know their incoming balance which mean its bricked\n    //     // TODO how does recipient find this event without trail decryption? Should we do a public event with a encrypted field instead?? Yes\n    //     // Should we do something with finding the txs that enques to recipients address instead. No sucks too much work\n    //     Transfer { sender, recipient, amount, embedded_amount_nonce }.emit(encode_and_encrypt_event(\n    //         &mut context,\n    //         recipient,\n    //         sender\n    //     ));\n\n    //     // give it to our recipient\n    //     let recipient_received_amounts_storage_slot = storage.received_amounts.at(recipient).storage_slot;\n\n    //     // TODO how tf do i get the point instead of a Field value?? its a hash of somehting for sure. But what?\n    //     // EmbeddedCurvePoint::generator(); is obviously not the way to do it ofc\n    //     let block_header = context.get_block_header();\n    //     let current_recipient_amount_point =  historical_public_storage_read(block_header,context.this_address(),recipient_received_amounts_storage_slot );//EmbeddedCurvePoint::generator(); //context.historical_header.public_storage_historical_read( recipient_received_amounts_storage_slot, context.this_address());\n    //     let new_recipient_amount_point: EmbeddedCurvePoint = embedded_curve_add(current_recipient_amount_point, embedded_amount);\n    //     // TODO why &mut ??\n    //     AccountBasedPrivacy::at(context.this_address()).set_received_amount(recipient, new_recipient_amount_point).enqueue(&mut context);\n\n    // }\n\n    // #[public]\n    // fn set_received_amount(address: AztecAddress, amount: EmbeddedCurvePoint) {\n    //     assert(context.msg_sender() == context.this_address(), \"only contract can call this function\");\n    //     storage.received_amounts.at(address).write(amount);\n    // }\n\n\n\n    // the account\n    // spentBalance\n    // logs PXE wil do that\n}\n"
    },
    "52": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "67": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "88": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n"
    },
    "96": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "98": {
      "path": "/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    }
  }
}
